[
  {
    "id": "1",
    "name": "Разработка на VueJS",
    "description": "Курс предоставляет комплексное руководство по созданию интерактивных и масштабируемых веб-приложений с использованием Vue.js. В рамках курса студенты освоят основные концепции фреймворка, включая компоненты, реактивность, маршрутизацию и работу с API. Курс включает практические примеры, которые помогут развить навыки разработки с использованием Vue, а также ознакомит с передовыми подходами и инструментами для создания современных веб-приложений.",
    "themeColor": "green",
    "img": "Vue.png",
    "nodes": {
      "1": {
        "id": "1",
        "name": "Основы",
        "root": true,
        "modules": [
          {
            "id": "11",
            "title": "Фреймворк VueJS",
            "content": "<section><h1>Что такое Vue.js?</h1><p><strong>Vue.js</strong> — это прогрессивный фреймворк для создания пользовательских интерфейсов. Он ориентирован на простоту, гибкость и реактивность данных, что делает его особенно удобным для начинающих разработчиков, а также мощным инструментом для построения масштабируемых SPA (одностраничных приложений).</p><h2>Ключевые особенности Vue.js:</h2><ul><li><strong>Декларативный рендеринг</strong> — данные автоматически синхронизируются с DOM благодаря реактивной системе Vue.</li><li><strong>Компонентный подход</strong> — интерфейс разбивается на переиспользуемые и изолированные компоненты.</li><li><strong>Простота интеграции</strong> — Vue легко встраивается в существующие проекты на JavaScript.</li><li><strong>Поддержка инструментов</strong> — экосистема включает Vue CLI, Vue Router, Vuex и DevTools для удобной разработки.</li></ul><h2>Заключение</h2><p>Vue.js — современный и легкий инструмент для разработки интерфейсов, идеально подходящий для старта в мире веб-разработки и создания мощных веб-приложений.</p></section>"
          },
          {
            "id": "12",
            "title": "Инициализация проекта",
            "content": "<section><h1>Инициализация проекта Vue</h1><p>Для создания нового проекта на Vue рекомендуется использовать <strong>Vite</strong> — быстрый и современный сборщик, официально поддерживаемый Vue-сообществом. Альтернативой является Vue CLI.</p><h2>Шаги инициализации с Vite:</h2><ul><li>Установка: <code>npm create vite@latest</code></li><li>Выбор шаблона: <code>vue</code> или <code>vue-ts</code> для TypeScript</li><li>Установка зависимостей: <code>cd project && npm install</code></li><li>Запуск проекта: <code>npm run dev</code></li></ul><h2>Почему Vite?</h2><ul><li>Мгновенный старт благодаря ESM</li><li>Горячая перезагрузка (HMR)</li><li>Поддержка Vue 3 из коробки</li></ul><p>Для создания SPA-приложений с расширенной конфигурацией можно использовать <code>vue-cli</code>: <code>npm install -g @vue/cli</code> и <code>vue create project</code>.</p><h2>Заключение</h2><p>Инициализация проекта с помощью Vite даёт современную, быструю и удобную стартовую точку для разработки на Vue.js.</p></section>"
          },
          {
            "id": "13",
            "title": "История",
            "content": "<section><h1>История и развитие Vue.js</h1><p><strong>Vue.js</strong> был создан Эваном Ю в 2014 году как альтернатива тяжеловесным фреймворкам. Его главная цель — быть простым в изучении, но мощным в производстве.</p><h2>Развитие:</h2><ul><li><strong>Vue 2 (2016)</strong> — популярность за счёт удобства, двухсторонней привязки данных и компонентов.</li><li><strong>Vue 3 (2020)</strong> — переход на Composition API, улучшенная производительность и поддержка TypeScript.</li><li><strong>Vue 3.3+</strong> — современная экосистема: Vite, Pinia, Vue Router и др.</li></ul><h2>Заключение</h2><p>Знание истории фреймворка позволяет глубже понять его философию и выбрать подходящие инструменты для разработки.</p></section>"
          }
        ]
      },
      "2": {
        "id": "2",
        "name": "Компоненты",
        "modules": [
          {
            "id": "21",
            "title": "Компонентный подход",
            "content": "<section><h1>Компонентный подход во Vue</h1><p>Vue основан на идее разделения интерфейса на независимые переиспользуемые блоки — <strong>компоненты</strong>.</p><h2>Преимущества:</h2><ul><li>Инкапсуляция логики и шаблона</li><li>Переиспользуемость</li><li>Лёгкое тестирование</li></ul><h2>Пример базового компонента:</h2><pre><code>&lt;template&gt;&lt;p&gt;Привет, {{ name }}!&lt;/p&gt;&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  props: ['name']\n}\n&lt;/script&gt;</code></pre><h2>Заключение</h2><p>Компоненты — фундамент Vue-приложений. Они делают код читаемым, масштабируемым и переиспользуемым.</p></section>"
          },
          {
            "id": "22",
            "title": "Составные части компонента",
            "content": "<section><h1>Структура компонента Vue</h1><p>Обычно компонент Vue включает три блока:</p><ul><li><code>&lt;template&gt;</code> — HTML-шаблон</li><li><code>&lt;script&gt;</code> — логика и данные</li><li><code>&lt;style&gt;</code> — стили компонента</li></ul><h2>Особенности:</h2><ul><li>Scoped-стили ограничивают область применения CSS</li><li>Composition API и Options API — альтернативные способы описания логики</li><li>Поддержка TypeScript</li></ul><p>Разделение структуры по этим блокам делает код организованным и удобным для поддержки.</p></section>"
          }
        ]
      },
      "3": {
        "id": "3",
        "name": "OptionsAPI и CompositionAPI",
        "modules": [
          {
            "id": "31",
            "title": "Способы определения компонентов",
            "content": "<section><h1>Способы определения компонентов во Vue</h1><p>Vue предлагает два API для создания компонентов:</p><ul><li><strong>Options API</strong> — декларативный способ с разделением логики</li><li><strong>Composition API</strong> — композиционный подход для гибкости и повторного использования</li></ul><h2>Сравнение:</h2><ul><li>Options API проще в освоении</li><li>Composition API масштабируется и подходит для крупных проектов</li></ul><p>Оба API могут использоваться вместе в одном приложении.</p></section>"
          },
          {
            "id": "32",
            "title": "OptionsAPI",
            "content": "<section><h1>Options API во Vue</h1><p><strong>Options API</strong> — традиционный способ описания компонентов через объект с опциями:</p><ul><li><code>data</code> — данные компонента</li><li><code>methods</code> — методы</li><li><code>computed</code> — вычисляемые свойства</li><li><code>watch</code> — наблюдатели</li></ul><p>Такой подход удобен новичкам и подходит для небольших проектов.</p></section>"
          }
        ]
      },
      "4": {
        "id": "4",
        "name": "Маршрутизация (Router)",
        "modules": [
          {
            "id": "41",
            "title": "Vue Router",
            "content": "<section><h1>Vue Router</h1><p><strong>Vue Router</strong> — официальный маршрутизатор для Vue.js, позволяющий создавать SPA с навигацией по URL без перезагрузки страницы.</p><h2>Возможности:</h2><ul><li>Настройка маршрутов</li><li>Динамические параметры</li><li>Ленивая загрузка компонентов</li></ul><p>Он интегрируется с Vue и поддерживает навигацию, охрану маршрутов и вложенные маршруты.</p></section>"
          },
          {
            "id": "42",
            "title": "Инициализация маршрутизатора",
            "content": "<section><h1>Инициализация Vue Router</h1><p>Для добавления маршрутизации:</p><ol><li>Установка: <code>npm install vue-router</code></li><li>Создание <code>router.js</code> с конфигурацией маршрутов</li><li>Подключение к приложению: <code>app.use(router)</code></li></ol><p>Использование маршрутизатора позволяет легко переключать компоненты при переходе по ссылкам.</p></section>"
          }
        ]
      },
      "5": {
        "id": "5",
        "name": "Анимации",
        "modules": [
          {
            "id": "51",
            "title": "Анимации во VueJS",
            "content": "<section><h1>Анимации во Vue</h1><p>Vue поддерживает встроенные переходы и анимации с помощью директивы <code>&lt;transition&gt;</code>.</p><h2>Ключевые моменты:</h2><ul><li>CSS-анимации и переходы</li><li>JavaScript-хуки</li><li>Переходы между маршрутами</li></ul><p>Библиотеки, такие как Animate.css или GSAP, можно интегрировать для расширенных эффектов.</p></section>"
          },
          {
            "id": "52",
            "title": "Начало работы",
            "content": "<section><h1>Начало работы с анимациями</h1><p>Чтобы добавить анимации:</p><ul><li>Обёртываем элемент в <code>&lt;transition name=\"fade\"&gt;</code></li><li>Добавляем стили: <code>.fade-enter-active</code>, <code>.fade-leave-active</code> и т.д.</li></ul><p>Переходы делают интерфейс живым и отзывчивым.</p></section>"
          }
        ]
      },
      "6": {
        "id": "6",
        "name": "Хранилище (Store)",
        "modules": [
          {
            "id": "61",
            "title": "State-менеджеры",
            "content": "<section><h1>Vuex и Pinia</h1><p>Vue предлагает два основных способа управления состоянием:</p><ul><li><strong>Vuex</strong> — старое, но мощное решение</li><li><strong>Pinia</strong> — официальная замена Vuex, рекомендованная для Vue 3</li></ul><p>Хранилище централизует данные и делает их доступными во всех компонентах.</p></section>"
          },
          {
            "id": "62",
            "title": "Инициализация хранилища",
            "content": "<section><h1>Инициализация Pinia</h1><p>Для начала работы:</p><ol><li><code>npm install pinia</code></li><li>Создание и регистрация хранилища</li><li>Использование <code>defineStore</code> для создания стора</li></ol><p>Pinia предоставляет удобный и реактивный способ управления глобальным состоянием.</p></section>"
          }
        ]
      },
      "7": {
        "id": "7",
        "name": "Динамическая разметка",
        "modules": [
          {
            "id": "71",
            "title": "v-if и v-show",
            "content": "<section><h1>Условный рендеринг</h1><p>Vue предоставляет директивы <code>v-if</code> и <code>v-show</code> для отображения элементов в зависимости от условий.</p><ul><li><code>v-if</code> — элемент добавляется/удаляется из DOM</li><li><code>v-show</code> — элемент остаётся в DOM, но скрывается с помощью <code>display: none</code></li></ul><p>Используйте <code>v-if</code> при тяжёлых компонентах, а <code>v-show</code> — при частом переключении.</p></section>"
          },
          {
            "id": "72",
            "title": "v-for",
            "content": "<section><h1>Рендеринг списков</h1><p>Для вывода массива используется <code>v-for</code>:</p><pre><code>&lt;li v-for=\"item in items\" :key=\"item.id\"&gt;{{ item.name }}&lt;/li&gt;</code></pre><p>Важно указывать <code>key</code> для производительности и корректного обновления.</p></section>"
          },
          {
            "id": "73",
            "title": "v-bind и v-model",
            "content": "<section><h1>Связывание данных</h1><p><code>v-bind</code> позволяет динамически задавать значения атрибутов, а <code>v-model</code> — создавать двухстороннюю привязку:</p><pre><code>&lt;input v-model=\"username\" /&gt;</code></pre><p>Это облегчает работу с формами и пользовательским вводом.</p></section>"
          }
        ]
      },
      "8": {
        "id": "8",
        "name": "Работа с API",
        "modules": [
          {
            "id": "81",
            "title": "fetch и axios",
            "content": "<section><h1>HTTP-запросы во Vue</h1><p>Для получения данных из внешних API можно использовать:</p><ul><li><code>fetch</code> — встроенный в браузер</li><li><code>axios</code> — популярная библиотека с расширенными возможностями</li></ul><p>Оба метода позволяют отправлять GET, POST и другие запросы с обработкой ответов и ошибок.</p></section>"
          },
          {
            "id": "82",
            "title": "Асинхронные компоненты",
            "content": "<section><h1>Асинхронные данные</h1><p>Vue компоненты могут загружать данные при создании с помощью <code>onMounted</code> или <code>created</code>:</p><pre><code>onMounted(async () => {\n  const res = await fetch(url)\n  data.value = await res.json()\n})</code></pre><p>Такой подход позволяет запрашивать API при загрузке компонента.</p></section>"
          },
          {
            "id": "83",
            "title": "Обработка ошибок",
            "content": "<section><h1>Обработка ошибок при запросах</h1><p>В случае сетевых ошибок важно предусмотреть обработку исключений:</p><pre><code>try {\n  await fetch(...)\n} catch (e) {\n  console.error(e)\n}</code></pre><p>Vue также позволяет отображать fallback-интерфейс при ошибках загрузки.</p></section>"
          }
        ]
      }
    },

    "edges": {
      "1": { "source": "1", "target": "2" },
      "2": { "source": "2", "target": "3" },
      "3": { "source": "3", "target": "4" },
      "4": { "source": "4", "target": "5" },
      "5": { "source": "4", "target": "6" },
      "6": { "source": "6", "target": "7" },
      "7": { "source": "6", "target": "8" }
    },

    "layouts": {
      "nodes": {
        "1": { "x": 0, "y": 0 },
        "2": { "x": 0, "y": 100 },
        "3": { "x": 0, "y": 200 },
        "4": { "x": 0, "y": 300 },
        "5": { "x": 100, "y": 400 },
        "6": { "x": -100, "y": 400 },
        "7": { "x": -200, "y": 500 },
        "8": { "x": 0, "y": 500 }
      }
    }
  },
  {
    "id": "2",
    "name": "Разработка на ReactJS",
    "description": "Курс охватывает основные концепции и передовые практики для создания динамичных и эффективных веб-приложений с использованием React. В рамках курса рассматриваются ключевые темы, такие как создание компонентов, использование хуков, маршрутизация, работа с API и управление состоянием. Этот курс предназначен для разработчиков, желающих углубить свои знания в React и освоить современные методы разработки с применением лучших практик и инструментов.",
    "img": "React.png",
    "themeColor": "blue",
    "nodes": {
      "1": {
        "id": "1",
        "name": "Основы",
        "root": true,
        "modules": [
          {
            "id": "11",
            "title": "Что такое ReactJS",
            "content": "<section><h1>Что такое ReactJS</h1><p><strong>ReactJS</strong> — это библиотека JavaScript с открытым исходным кодом для создания пользовательских интерфейсов, разработанная Facebook. Она ориентирована на создание компонентов и эффективную отрисовку интерфейса.</p></section>"
          },
          {
            "id": "12",
            "title": "История и развитие React",
            "content": "<section><h1>История и развитие React</h1><p>React был представлен в 2013 году и быстро стал популярным благодаря своей простоте, Virtual DOM и компонентному подходу. Сейчас React поддерживает хуки и современные средства разработки интерфейсов.</p></section>"
          },
          {
            "id": "13",
            "title": "Создание первого приложения",
            "content": "<section><h1>Создание первого приложения</h1><p>React-приложение можно создать с помощью <code>create-react-app</code>: <code>npx create-react-app my-app</code>. Далее структура проекта готова к разработке компонентов и интерфейсов.</p></section>"
          }
        ]
      },
      "2": {
        "id": "2",
        "name": "Компоненты React",
        "modules": [
          {
            "id": "21",
            "title": "Функциональные и классовые компоненты",
            "content": "<section><h1>Функциональные и классовые компоненты</h1><p>React позволяет создавать компоненты как функции, так и классы. Современные проекты используют <strong>функциональные компоненты</strong> с хуками.</p></section>"
          },
          {
            "id": "22",
            "title": "Переиспользование компонентов",
            "content": "<section><h1>Переиспользование компонентов</h1><p>Компоненты можно многократно использовать, передавая им <code>props</code> — параметры, определяющие их поведение или отображение.</p></section>"
          },
          {
            "id": "23",
            "title": "Жизненный цикл компонентов",
            "content": "<section><h1>Жизненный цикл компонентов</h1><p>У классовых компонентов есть методы жизненного цикла, такие как <code>componentDidMount</code>. В функциональных компонентах аналог реализуется через хук <code>useEffect</code>.</p></section>"
          }
        ]
      },
      "3": {
        "id": "3",
        "name": "Синтаксис JSX",
        "modules": [
          {
            "id": "31",
            "title": "Основы JSX",
            "content": "<section><h1>Основы JSX</h1><p>JSX — это синтаксическое расширение JavaScript, позволяющее писать HTML-подобный код внутри JavaScript. Он компилируется в вызовы <code>React.createElement</code>.</p></section>"
          },
          {
            "id": "32",
            "title": "Вставка JavaScript в JSX",
            "content": "<section><h1>Вставка JavaScript в JSX</h1><p>Внутри JSX можно вставлять JavaScript-выражения, заключив их в фигурные скобки: <code>{expression}</code>.</p></section>"
          },
          {
            "id": "33",
            "title": "Правила и ограничения JSX",
            "content": "<section><h1>Правила и ограничения JSX</h1><p>JSX требует единственного корневого элемента, использование <code>className</code> вместо <code>class</code>, и соблюдение синтаксиса HTML.</p></section>"
          }
        ]
      },
      "4": {
        "id": "4",
        "name": "Обработка событий",
        "modules": [
          {
            "id": "41",
            "title": "Добавление событий",
            "content": "<section><h1>Добавление событий</h1><p>Обработчики событий в React задаются как свойства элементов: <code>&lt;button onClick={handleClick}&gt;</code>. Названия событий пишутся в camelCase.</p></section>"
          },
          {
            "id": "42",
            "title": "Передача аргументов в обработчики",
            "content": "<section><h1>Передача аргументов в обработчики</h1><p>Чтобы передать параметры, используйте стрелочную функцию: <code>onClick={() => handleClick(id)}</code>.</p></section>"
          },
          {
            "id": "43",
            "title": "Работа с SyntheticEvent",
            "content": "<section><h1>Работа с SyntheticEvent</h1><p>React использует <strong>SyntheticEvent</strong> — кроссбраузерную обёртку над нативными событиями, обеспечивающую единое поведение.</p></section>"
          }
        ]
      },
      "5": {
        "id": "5",
        "name": "Хуки React",
        "modules": [
          {
            "id": "51",
            "title": "useState и useEffect",
            "content": "<section><h1>useState и useEffect</h1><p>Хуки позволяют использовать состояние и эффекты в функциональных компонентах. <code>useState</code> управляет данными, <code>useEffect</code> запускает побочные эффекты.</p></section>"
          },
          {
            "id": "52",
            "title": "useRef и useMemo",
            "content": "<section><h1>useRef и useMemo</h1><p><code>useRef</code> используется для хранения мутабельных значений, <code>useMemo</code> — для мемоизации тяжёлых вычислений между рендерами.</p></section>"
          },
          {
            "id": "53",
            "title": "Создание собственных хуков",
            "content": "<section><h1>Создание собственных хуков</h1><p>Можно создавать свои хуки, начинающиеся с <code>use</code>, чтобы выделить повторяющуюся бизнес-логику в отдельные функции.</p></section>"
          }
        ]
      },
      "6": {
        "id": "6",
        "name": "Управление состоянием (State-management)",
        "modules": [
          {
            "id": "61",
            "title": "Подъём состояния (Lifting state up)",
            "content": "<section><h1>Подъём состояния (Lifting state up)</h1><p>Общий стейт между компонентами поднимается в их общего родителя, который управляет им и передаёт данные через <code>props</code>.</p></section>"
          },
          {
            "id": "62",
            "title": "Контекст (Context API)",
            "content": "<section><h1>Контекст (Context API)</h1><p><code>React.createContext</code> позволяет передавать данные через дерево компонентов без необходимости пробрасывать <code>props</code> вручную на каждом уровне.</p></section>"
          },
          {
            "id": "63",
            "title": "Управление состоянием с помощью useReducer",
            "content": "<section><h1>Управление состоянием с помощью useReducer</h1><p><code>useReducer</code> предоставляет альтернативу <code>useState</code>, особенно полезен для сложной логики с множеством состояний и переходов между ними.</p></section>"
          }
        ]
      },
      "7": {
        "id": "7",
        "name": "Маршрутизация (Routing)",
        "modules": [
          {
            "id": "71",
            "title": "Основы React Router",
            "content": "<section><h1>Основы React Router</h1><p>React Router позволяет создавать SPA с несколькими страницами. Используются компоненты <code>&lt;Routes&gt;</code> и <code>&lt;Route&gt;</code> для определения маршрутов.</p></section>"
          },
          {
            "id": "72",
            "title": "Динамические маршруты",
            "content": "<section><h1>Динамические маршруты</h1><p>С помощью <code>:param</code> можно создать динамические адреса, например: <code>/user/:id</code>. Компонент получает параметры через <code>useParams()</code>.</p></section>"
          },
          {
            "id": "73",
            "title": "Навигация и вложенные маршруты",
            "content": "<section><h1>Навигация и вложенные маршруты</h1><p>Для перехода между страницами используется хук <code>useNavigate</code>. Вложенные маршруты позволяют создавать иерархию страниц с <code>Outlet</code>.</p></section>"
          }
        ]
      },
      "8": {
        "id": "8",
        "name": "Работа с API (RTK-Query)",
        "modules": [
          {
            "id": "81",
            "title": "Основы RTK-Query",
            "content": "<section><h1>Основы RTK-Query</h1><p>RTK Query — это инструмент из Redux Toolkit, упрощающий взаимодействие с API, управление кэшированием и состоянием запросов.</p></section>"
          },
          {
            "id": "82",
            "title": "Создание endpoints и запросов",
            "content": "<section><h1>Создание endpoints и запросов</h1><p>Создайте API slice с помощью <code>createApi</code>, опишите endpoints (query/mutation) и подключите middleware к хранилищу Redux.</p></section>"
          },
          {
            "id": "83",
            "title": "Кэширование и обновление данных",
            "content": "<section><h1>Кэширование и обновление данных</h1><p>RTK Query автоматически кэширует данные, позволяет вручную обновлять/инвалидировать кэш, обеспечивая свежесть и производительность.</p></section>"
          }
        ]
      }
    },
    "edges": {
      "edge1": { "source": "1", "target": "2" },
      "edge2": { "source": "2", "target": "3" },
      "edge3": { "source": "2", "target": "4" },
      "edge4": { "source": "4", "target": "5" },
      "edge5": { "source": "5", "target": "6" },
      "edge6": { "source": "6", "target": "7" },
      "edge7": { "source": "6", "target": "8" }
    },

    "layouts": {
      "nodes": {
        "1": { "x": 0, "y": 0 },
        "2": { "x": 0, "y": 100 },
        "3": { "x": 100, "y": 200 },
        "4": { "x": -100, "y": 200 },
        "5": { "x": -100, "y": 300 },
        "6": { "x": -100, "y": 400 },
        "7": { "x": -250, "y": 500 },
        "8": { "x": 50, "y": 500 }
      }
    }
  }
]
